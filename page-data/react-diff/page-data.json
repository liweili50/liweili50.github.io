{"componentChunkName":"component---src-templates-blog-post-js","path":"/react-diff/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Blog"}},"markdownRemark":{"id":"6d7bf47b-49c1-5332-b75c-d92b76c06b9f","excerpt":"当你使用React，在单一时间点你可以考虑render()函数作为创建React元素的树。在下一次状态或属性更新，render()函数将返回一个不同的React元素的树。React需要算出如何高效更新UI以匹配最新的树。 有一些解决将一棵树转换为另一棵树的最小操作数算法问题的通用方案。然而，树中元素个数为n…","html":"<p>当你使用React，在单一时间点你可以考虑render()函数作为创建React元素的树。在下一次状态或属性更新，render()函数将返回一个不同的React元素的树。React需要算出如何高效更新UI以匹配最新的树。</p>\n<p>有一些解决将一棵树转换为另一棵树的最小操作数算法问题的通用方案。然而，树中元素个数为n，最先进的算法 的时间复杂度为O(n3) 。</p>\n<p>若我们在React中使用，展示1000个元素则需要进行10亿次的比较。这操作太过昂贵，相反，React基于两点假设，实现了一个启发的O(n)算法：</p>\n<p>两个不同类型的元素将产生不同的树。\n通过渲染器附带key属性，开发者可以示意哪些子元素可能是稳定的。\n实践中，上述假设适用于大部分应用场景。</p>\n<p>对比算法\n当对比两棵树时，React首先比较两个根节点。根节点的type不同，其行为也不同。</p>\n<p>不同类型的元素\n每当根元素有不同类型，React将卸载旧树并重新构建新树。从<code class=\"language-text\">&lt;a></code>到<code class=\"language-text\">&lt;img></code>或从<code class=\"language-text\">&lt;Article></code>到<code class=\"language-text\">&lt;Comment></code>，或从<code class=\"language-text\">&lt;Button></code> 到 <code class=\"language-text\">&lt;div></code>，任何的调整都会导致全部重建。</p>\n<p>当树被卸载，旧的DOM节点将被销毁。组件实例会调用componentWillUnmount()。当构建一棵新树，新的DOM节点被插入到DOM中。组件实例将依次调用componentWillMount()和componentDidMount()。任何与旧树有关的状态都将丢弃。</p>\n<p>这个根节点下所有的组件都将会被卸载，同时他们的状态将被销毁。 例如，以下节点对比之后：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>Counter <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n\n<span class=\"token operator\">&lt;</span>span<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>Counter <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>span<span class=\"token operator\">></span></code></pre></div>\n<p>这将会销毁旧的Counter并重装新的Counter。</p>\n<p>相同类型的DOM元素\n当比较两个相同类型的React DOM元素时，React则会观察二者的属性，保持相同的底层DOM节点，并仅更新变化的属性。例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"before\"</span> title<span class=\"token operator\">=</span><span class=\"token string\">\"stuff\"</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n\n<span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"after\"</span> title<span class=\"token operator\">=</span><span class=\"token string\">\"stuff\"</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span></code></pre></div>\n<p>通过比较两个元素，React知道仅更改底层DOM元素的className。</p>\n<p>当更新style时，React同样知道仅更新变更的属性。例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>div style<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>color<span class=\"token operator\">:</span> <span class=\"token string\">'red'</span><span class=\"token punctuation\">,</span> fontWeight<span class=\"token operator\">:</span> <span class=\"token string\">'bold'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n\n<span class=\"token operator\">&lt;</span>div style<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>color<span class=\"token operator\">:</span> <span class=\"token string\">'green'</span><span class=\"token punctuation\">,</span> fontWeight<span class=\"token operator\">:</span> <span class=\"token string\">'bold'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span></code></pre></div>\n<p>当在调整两个元素时，React知道仅改变color样式而不是fontWeight。</p>\n<p>在处理完DOM元素后，React递归其子元素。</p>\n<p>相同类型的组件元素\n当组件更新时，实例仍保持一致，以让状态能够在渲染之间保留。React通过更新底层组件实例的props来产生新元素，并在底层实例上依次调用componentWillReceiveProps() 和 componentWillUpdate() 方法。</p>\n<p>接下来，render()方法被调用，同时对比算法会递归处理之前的结果和新的结果。</p>\n<p>递归子节点\n默认时。当递归DOM节点的子节点，React仅在同一时间点递归两个子节点列表，并在有不同时产生一个变更。</p>\n<p>例如，当在子节点末尾增加一个元素，两棵树的转换效果很好：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>ul<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>li<span class=\"token operator\">></span>first<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>li<span class=\"token operator\">></span>second<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>ul<span class=\"token operator\">></span>\n\n<span class=\"token operator\">&lt;</span>ul<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>li<span class=\"token operator\">></span>first<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>li<span class=\"token operator\">></span>second<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>li<span class=\"token operator\">></span>third<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>ul<span class=\"token operator\">></span></code></pre></div>\n<p>React将会匹配两棵树的<code class=\"language-text\">&lt;li>first&lt;/li></code>，并匹配两棵树的<code class=\"language-text\">&lt;li>second&lt;/li></code> 节点，并插入<code class=\"language-text\">&lt;li>third&lt;/li></code>节点树。</p>\n<p>若原生实现，在开始插入元素会使得性能更棘手。例如，两棵树的转换效果则比较糟糕：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;ul>\n  &lt;li>Duke&lt;/li>\n  &lt;li>Villanova&lt;/li>\n&lt;/ul>\n\n&lt;ul>\n  &lt;li>Connecticut&lt;/li>\n  &lt;li>Duke&lt;/li>\n  &lt;li>Villanova&lt;/li>\n&lt;/ul></code></pre></div>\n<p>React会调整每个子节点，而非意识到可以完整保留<code class=\"language-text\">&lt;li>Duke&lt;/li></code> 和 <code class=\"language-text\">&lt;li>Villanova&lt;/li></code>子树。低效成了一个问题。</p>\n<p>Keys\n为解决该问题，React支持了一个key属性。当子节点有key时，React使用key来匹配原本树的子节点和新树的子节点。例如，增加一个key在之前效率不高的样例中能让树的转换变得高效：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>ul<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>li key<span class=\"token operator\">=</span><span class=\"token string\">\"2015\"</span><span class=\"token operator\">></span>Duke<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>li key<span class=\"token operator\">=</span><span class=\"token string\">\"2016\"</span><span class=\"token operator\">></span>Villanova<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>ul<span class=\"token operator\">></span>\n\n<span class=\"token operator\">&lt;</span>ul<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>li key<span class=\"token operator\">=</span><span class=\"token string\">\"2014\"</span><span class=\"token operator\">></span>Connecticut<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>li key<span class=\"token operator\">=</span><span class=\"token string\">\"2015\"</span><span class=\"token operator\">></span>Duke<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>li key<span class=\"token operator\">=</span><span class=\"token string\">\"2016\"</span><span class=\"token operator\">></span>Villanova<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>ul<span class=\"token operator\">></span></code></pre></div>\n<p>现在React知道带有’2014’的key的元素是新的，并仅移动带有’2015’和’2016’的key的元素。</p>\n<p>实践中，发现key通常不难。你将展示的元素可能已经带有一个唯一的ID，因此key可以来自于你的数据中：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>li key<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span></code></pre></div>\n<p>当这已不再是问题，你可以给你的数据增加一个新的ID属性，或根据数据的某些内容创建一个哈希值来作为key。key必须在其兄弟节点中是唯一的，而非全局唯一。</p>\n<p>万不得已，你可以传递他们在数组中的索引作为key。若元素没有重排，该方法效果不错，但重排会使得其变慢。</p>\n<p>当索引用作key时，组件状态在重新排序时也会有问题。组件实例基于key进行更新和重用。如果key是索引，则item的顺序变化会改变key值。这将导致非受控组件的状态可能会以意想不到的方式混淆和更新。</p>\n<p>这里是在CodePen上使用索引作为键可能导致的问题的一个例子，这里是同一个例子的更新版本，展示了如何不使用索引作为键将解决这些reordering, sorting, 和 prepending的问题。</p>\n<p>权衡\n牢记协调算法的实现细节非常重要。React可能会在每次操作时渲染整个应用；而结果仍是相同的。为保证大多数场景效率能更快，我们通常提炼启发式的算法。</p>\n<p>在目前实现中，可以表明一个事实，即子树在其兄弟节点中移动，但你无法告知其移动到哪。该算法会重渲整个子树。</p>\n<p>由于React依赖于该启发式算法，若其背后的假设没得到满足，则其性能将会受到影响：</p>\n<p>算法无法尝试匹配不同组件类型的子元素。若你发现两个输出非常相似的组件类型交替出现，你可能希望使其成为相同类型。实践中，我们并非发现这是一个问题。</p>\n<p>Keys应该是稳定的，可预测的，且唯一的。不稳定的key（类似由Math.random()生成的）将使得大量组件实例和DOM节点进行不必要的重建，使得性能下降并丢失子组件的状态。</p>","frontmatter":{"title":"React Diff 算法原理","date":"December 06, 2018","description":""}},"previous":{"fields":{"slug":"/sum-of-two-number/"},"frontmatter":{"title":"两数之和"}},"next":{"fields":{"slug":"/single-thread/"},"frontmatter":{"title":"定时器运行机制"}}},"pageContext":{"id":"6d7bf47b-49c1-5332-b75c-d92b76c06b9f","previousPostId":"454b855f-4c5e-598d-8eff-91371a596d30","nextPostId":"7074a15b-dab2-58ae-a922-d689d212e743"}},"staticQueryHashes":["2841359383","3257411868"]}